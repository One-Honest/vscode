<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>53.深拷贝和浅拷贝</title>
    <script src="tools/tools.js"></script>
    <script>
        /*
        1.什么是深拷贝?
            修改新变量的值不影响原有变量的值;默认情况下基本数据类型都是深拷贝;
            let num=123;
            num1=num;
            num1=444;//修改新变量的值不会影响原有变量num的值
            console.log(num);
            console.log(num1);


        class Person{
            name="谢壹诚";
            cat={
               age:3
            };
            scores=[1,3,5];
        }
        let p1=new Person();//new后会分配一个存储空间给p
        let p2=new Object();//new后会另外分配一个存储空间给p1
        方法1  仅适用于基本数据类型
        p2.name=p1.name;
                p2.name="壹诚谢";//修改了新变量p2的name属性值,原有变量p1的的name属性值没有被修改;
        方法2 仅适用于基本数据类型
        for(let key in p1){//遍历p1中的所有属性
                p2[key]=p1[key];//将p1中的属性值动态赋值给p2;
        }
        p2.name="壹诚谢";
        /*方法3  仅适用于基本数据类型
        Object.assign(p2,p1);//assign方法可以将第二个对象的属性和方法深拷贝到第一个对象中;
                p2.name="壹诚谢谢";
        2.什么是浅拷贝?
            修改新变量的值会影响原有变量的值;默认情况下引用类型都是浅拷贝;
            class Person{
            name="谢壹诚";
            }
            let p=new Person();
            let p1=p;//此处将p的值赋值给p1,只是将p的地址传递给p1;两者的数据存储在同一个存储空间;
            p1.name="壹诚谢";//修改了新变量p1的name属性值,原有变量p的的name属性值也随之被修改;
            console.log(p.name);
            console.log(p1.name);
        */
        //由浅拷贝变深拷贝:
        class Person{
            name="谢壹诚";
            cat={
               age:3
            };
            scores=[1,3,5];
        }
        let p1=new Person();//new后会分配一个存储空间给p
        let p2=new Object();//new后会另外分配一个存储空间给p1
depCopy(p2,p1);//将p1中的属性和方法深拷贝到p2中;
        /* function depCopy(target,source){
            //1.通过遍历拿到source中的所有属性和方法;
            for(let key in source){
            //取出当前遍历到的属性和方法的取值;
            let sourceValue=source[key];
                if (sourceValue instanceof Object){//判断sourceValue是否是Object的实例对象;[所有对象都是Object的实例对象]
//这里是为了避免p2从p1中复制过来的数组或者函数会一起存储在p2的原型对象中;
                    let subTarget=new sourceValue.constructor;//通过constructor属性可以找到实例对象的构造函数,从而判断该实例对象是对象还是数组;
                                                            //再通过new来创造一个新的对象,这样就会创造出一个新的存储空间
                                                            //从而让p2中的数据存储在新的存储空间中,不影响p1存储空间中的数据;
                    depCopy(subTarget,sourceValue);//将遍历到的属性或者方法的值传递给新建的对象中;
                    target[key]=subTarget;//将新建的对象或数组放入target[key]中; 
                }else{
                    target[key]=sourceValue;//将基本类型数据直接放入target[key]中;
                }
            }
        } */
        console.log(p2);
        p2.cat.age=33;
        console.log(p1.cat.age);
        console.log(p2.cat.age);//p2的cat.age属性改变了,而p1的cat.age没改变,完成深拷贝;
        
    </script>
</head>
<body>
    
</body>
</html>